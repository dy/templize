const e={processCallback(e,t,s){if(s)for(const e of t)e.expression in s&&(e.value=s[e.expression])}};class t extends DocumentFragment{#e;#t;constructor(t,s,r=e){super(),this.appendChild(t.content.cloneNode(!0)),this.#e=l(this),this.#t=r,r.createCallback?.(this,this.#e,s),r.processCallback?.(this,this.#e,s)}update(e){this.#t.processCallback?.(this,this.#e,e)}}class s{constructor(e,t){this.setter=e,this.expression=t}toString(){return this.value}}class r extends s{#s="";get attributeName(){return this.setter.attr.name}get attributeNamespace(){return this.setter.attr.namespaceURI}get element(){return this.setter.element}get value(){return this.#s}set value(e){this.#s=e;const{attr:t,element:s,parts:r}=this.setter;1===r.length?null==e?s.removeAttributeNS(t.namespaceURI,t.name):s.setAttributeNS(t.namespaceURI,t.name,e):s.setAttributeNS(t.namespaceURI,t.name,r.join(""))}get booleanValue(){this.setter.element.hasAttribute(this.setter.attr.name)}set booleanValue(e){if(1!==this.setter.parts.length)throw new DOMException("Value is not fully templatized");this.value=e?"":null}}class n extends s{#r=[new Text];get replacementNodes(){return this.#r}get parentNode(){return this.setter.parentNode}get nextSibling(){return this.#r[this.#r.length-1].nextSibling}get previousSibling(){return this.#r[0].previousSibling}get value(){return this.#r.map((e=>e.textContent)).join("")}set value(e){this.replace(e)}replace(...e){e=e.length?e.flatMap((e=>e.forEach?[...e]:e.trim?[new Text(e)]:[e])):[new Text],this.#r=((e,t,s,r=null)=>{let n,a,l,i=0,o=s.length,p=t.length;for(;i<o&&i<p&&t[i]==s[i];)i++;for(;i<o&&i<p&&s[o-1]==t[p-1];)r=s[(--p,--o)];if(i==p)for(;i<o;)e.insertBefore(s[i++],r);else{for(n=t[i];i<o;)l=s[i++],a=n?n.nextSibling:r,n==l?n=a:i<o&&s[i]==a?(e.replaceChild(l,n),n=a):e.insertBefore(l,n);for(;n!=r;)a=n.nextSibling,e.removeChild(n),n=a}return s})(this.parentNode,this.#r,e,this.nextSibling)}replaceHTML(e){const t=this.parentNode.cloneNode();t.innerHTML=e,this.replace(t.childNodes)}}const a={},l=(e,t=[])=>{for(let s of e.attributes||[])if(s.value.includes("{{")){let n={element:e,attr:s,parts:[]};for(let[e,a]of i(s.value))e?(a=new r(n,a),n.parts.push(a),t.push(a)):n.parts.push(a);s.value=n.parts.join("")}for(let s of e.childNodes)if(1===s.nodeType)l(s,t);else if(3===s.nodeType&&s.data.includes("{{")){let r={parentNode:e,parts:[]};for(let[e,a]of i(s.data.trim()))e?(a=new n(r,a),r.parts.push(a),t.push(a)):r.parts.push(new Text(a));s.replaceWith(...r.parts.flatMap((e=>e.replacementNodes||[e])))}return t},i=e=>{let t,s="",r=0,n=a[e],l=0;if(n)return n;for(n=[];t=e[l];l++)"{"===t&&"{"===e[l+1]&&"\\"!==e[l-1]&&e[l+2]?1==++r&&(s&&n.push([0,s]),s="",l+=2):"}"===t&&"}"===e[l+1]&&"\\"!==e[l-1]&&(--r||(r=!1,n.push([1,s.trim()]),s="",l+=2)),s+=e[l]||"";return s&&n.push([0,s]),a[e]=n};var o=(t,s={},r=e)=>{let n,a=l(t),i=()=>!n&&(n=Promise.resolve().then((()=>(n=null,r.processCallback?.(t,a,s)))));return r.createCallback?.(t,a,s),r.processCallback?.(t,a,s),new Proxy(s,{set:(e,t,s)=>(e[t]=s,i(),1),deleteProperty:(e,t)=>(delete e[t],i())})};export{r as AttributeTemplatePart,n as NodeTemplatePart,t as TemplateInstance,s as TemplatePart,o as default,e as values};